<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Ollama Local Chat</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<style>
/* --- CSS Variables and Base Styles --- */
:root {
  --font-family-main: 'Inconsolata', 'Consolas', 'Menlo', monospace;
  --font-size-base: 14px;
  --font-size-sm: 12px;
  --font-size-lg: 16px;

  /* Dark Mode Palette */
  --bg-primary: #1A1A1B;       /* Main background - very dark grey */
  --bg-secondary: #272729;     /* Sidebar, input areas - dark grey */
  --bg-tertiary: #3A3A3C;      /* Bubbles, list items, hover - medium dark grey */
  --bg-accent: #007AFF;        /* Accent color (Apple's blue) */
  --bg-accent-hover: #0056b3;  /* Darker accent for hover */
  --bg-code: #1E1E1E;          /* Slightly different for code blocks if needed, or use secondary */
  --bg-thinking: #2C2C2E;      /* Thinking bubble background */
  --bg-error: #5C2B29;         /* Error background */
  --bg-success: #2A4B3A;       /* Success feedback background (e.g., copied) */

  --text-primary: #E0E0E0;     /* Main text - light grey */
  --text-secondary: #A0A0A0;   /* Secondary text, placeholders - medium grey */
  --text-accent: #FFFFFF;       /* White text on accent backgrounds */
  --text-code: #D4D4D4;         /* Code text */
  --text-link: var(--bg-accent);
  --text-error: #FFB8B3;        /* Error text color */
  --text-success: #B3FFD9;      /* Success text color */

  --border-color: #404040;     /* Border color - visible but not harsh */
  --border-color-strong: #555555; /* For more prominent borders if needed */
  --border-radius-base: 8px;
  --border-radius-sm: 5px;

  --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.3);
  --shadow-md: 0 3px 6px rgba(0, 0, 0, 0.4);

  --scrollbar-thumb: #555;
  --scrollbar-track: var(--bg-secondary);

  --padding-xs: 0.25rem; /* 4px */
  --padding-sm: 0.5rem;  /* 8px */
  --padding-md: 0.75rem; /* 12px */
  --padding-lg: 1rem;    /* 16px */

  --sidebar-width: 260px;
  --sidebar-width-collapsed: 60px; /* Example for future collapse */
}

* {
  box-sizing: border-box;
}

html, body {
  height: 100%;
  margin: 0;
  font-family: var(--font-family-main);
  font-size: var(--font-size-base);
  background-color: var(--bg-primary);
  color: var(--text-primary);
  display: flex; /* Lays out sidebar, main-content, and right-sidebar horizontally */
  overflow: hidden; /* Prevent body scrollbars if children are managed */
}

/* --- Scrollbar Styling --- */
::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}
::-webkit-scrollbar-track {
  background: var(--scrollbar-track);
}
::-webkit-scrollbar-thumb {
  background: var(--scrollbar-thumb);
  border-radius: 4px;
}
::-webkit-scrollbar-thumb:hover {
  background: #6a6a6a;
}

/* --- Sidebar Styling --- */
#sidebar {
  width: var(--sidebar-width);
  flex-shrink: 0; /* Prevent sidebar from shrinking */
  background-color: var(--bg-secondary);
  color: var(--text-primary);
  padding: var(--padding-lg);
  display: flex;
  flex-direction: column;
  border-right: 1px solid var(--border-color);
  height: 100vh; /* Ensure full viewport height */
  overflow-y: auto; /* Allow sidebar content to scroll if needed */
}

#sidebar a[style*='localllm'] { /* Targeting the logo */
  font-size: 20px !important; /* Overriding inline style for consistency */
  color: var(--text-secondary) !important;
  padding: var(--padding-lg) !important;
  text-align: center !important;
  margin-bottom: var(--padding-lg);
  display: block;
  text-decoration: none;
}

#new-conversation-btn {
  width: 100%;
  padding: var(--padding-md);
  margin-bottom: var(--padding-lg);
  border: 1px solid var(--border-color);
  border-radius: var(--border-radius-base);
  background-color: var(--bg-tertiary);
  color: var(--text-primary);
  cursor: pointer;
  font-family: var(--font-family-main);
  font-size: var(--font-size-base);
  transition: background-color 0.2s, border-color 0.2s;
}
#new-conversation-btn:hover {
  background-color: var(--bg-accent);
  color: var(--text-accent);
  border-color: var(--bg-accent-hover);
}

#conversation-list {
  list-style: none;
  padding: 0;
  margin: 0;
  flex-grow: 1; /* Allows the list to take available space in the sidebar */
  overflow-y: auto; /* Scroll within the list if it overflows */
  font-size: var(--font-size-base);
}

.conversation-item-container {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: var(--padding-md);
  border-radius: var(--border-radius-sm);
  margin-bottom: var(--padding-sm);
  background-color: var(--bg-tertiary);
  color: var(--text-secondary);
  cursor: pointer;
  transition: background-color 0.2s, color 0.2s;
  border: 1px solid transparent; /* Placeholder for hover/active border */
}
.conversation-item-container:hover {
  background-color: var(--bg-accent-hover);
  color: var(--text-accent);
}
.conversation-item-container.active {
  background-color: var(--bg-accent);
  color: var(--text-accent);
  border-color: var(--bg-accent-hover);
  font-weight: bold;
}

.conversation-name {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  flex-grow: 1;
  padding-right: var(--padding-sm); /* Space before model/actions */
}
.conversation-model {
  font-size: var(--font-size-sm);
  margin-left: var(--padding-sm);
  opacity: 0.8;
}
.conversation-actions button {
  background: none;
  border: none;
  color: var(--text-secondary);
  cursor: pointer;
  margin-left: var(--padding-xs);
  font-size: var(--font-size-lg); /* Make icons slightly larger */
  padding: var(--padding-xs);
  border-radius: var(--border-radius-sm);
}
.conversation-item-container:hover .conversation-actions button,
.conversation-item-container.active .conversation-actions button {
  color: var(--text-accent); /* Match text color on hover/active */
}
.conversation-actions button:hover {
  background-color: rgba(255, 255, 255, 0.1); /* Subtle hover for individual buttons */
}

.rename-input {
  flex-grow: 1;
  padding: var(--padding-xs) var(--padding-sm);
  border: 1px solid var(--border-color-strong);
  border-radius: var(--border-radius-sm);
  font-family: var(--font-family-main);
  font-size: var(--font-size-base);
  background-color: var(--bg-primary); /* Match primary background */
  color: var(--text-primary);
}

/* --- Main Content Area --- */
#main-content {
  flex: 1; /* Allows main content to take remaining width beside sidebar */
  display: flex;
  flex-direction: column; /* Stacks header, chat-log, input-area vertically */
  height: 100vh; /* Full viewport height */
  overflow: hidden; /* Prevent this container from showing scrollbars; children manage their own */
  background-color: var(--bg-primary);
}

/* Chat Header */
#chat-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: var(--padding-sm) var(--padding-lg);
  background: var(--bg-secondary);
  border-bottom: 1px solid var(--border-color);
  flex-shrink: 0; /* Prevent header from shrinking */
}
#current-conversation-title {
  font-weight: bold;
  font-size: var(--font-size-lg);
  color: var(--text-primary);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  max-width: calc(100% - 160px); /* Adjust based on button width */
}
#clear-conversation-btn {
  padding: var(--padding-sm) var(--padding-md);
  font-family: var(--font-family-main);
  font-size: var(--font-size-sm);
  background-color: var(--bg-tertiary);
  color: var(--text-secondary);
  border: 1px solid var(--border-color);
  border-radius: var(--border-radius-sm);
  cursor: pointer;
  transition: background-color 0.2s, color 0.2s;
}
#clear-conversation-btn:hover {
  background-color: #C82333; /* Keep a distinct danger color */
  color: var(--text-accent);
  border-color: #C82333;
}

/* Chat Log - CRUCIAL FOR LAYOUT */
#chat-log {
  flex: 1 1 auto; /* Allows chat log to grow and shrink, taking available vertical space */
  overflow-y: auto; /* Enables vertical scrolling FOR CHAT MESSAGES THEMSELVES */
  padding: var(--padding-lg);
  background: var(--bg-primary); /* Match primary background */
}

/* Messages and Bubbles */
.message {
  margin-bottom: var(--padding-lg);
  display: flex;
  opacity: 0;
  animation: fadeIn 0.3s forwards;
  position: relative;
}
@keyframes fadeIn { to { opacity: 1; } }

.message.user { justify-content: flex-end; }
.message.assistant { justify-content: flex-start; }

.bubble {
  max-width: 80%; /* Responsive max width */
  padding: var(--padding-md) var(--padding-lg);
  border-radius: var(--border-radius-base);
  line-height: 1.6;
  word-wrap: break-word;
  box-shadow: var(--shadow-sm);
  white-space: pre-wrap; /* Preserve whitespace and newlines */
  position: relative; /* For copy button */
}
.message.user .bubble {
  background: var(--bg-accent);
  color: var(--text-accent);
  border-bottom-right-radius: var(--border-radius-sm); /* Slightly different rounding */
}
.message.assistant .bubble {
  background: var(--bg-tertiary);
  color: var(--text-primary);
  border-bottom-left-radius: var(--border-radius-sm);
}

/* Thinking Bubble */
.message.thinking .bubble {
  background-color: var(--bg-thinking);
  border: 1px solid var(--border-color);
  border-radius: var(--border-radius-sm);
  padding: var(--padding-md);
  font-size: var(--font-size-sm);
  max-width: 100%;
  max-height: 100px; /* Increased slightly */
  overflow-y: auto;
  box-shadow: none;
  color: var(--text-secondary);
}
.message.assistant.thinking .bubble pre { /* if pre appears in thinking */
  font-size: 10px; /* smaller */
  background-color: var(--bg-secondary);
  color: var(--text-secondary);
}

/* Code Blocks */
.bubble pre {
  background-color: var(--bg-code);
  color: var(--text-code);
  padding: var(--padding-md);
  border-radius: var(--border-radius-sm);
  overflow-x: auto;
  font-family: var(--font-family-main); /* Ensure monospace for code */
  font-size: var(--font-size-base); /* Consistent font size */
  margin: var(--padding-sm) 0;
  position: relative;
  border: 1px solid var(--border-color);
}
.copy-code-btn {
  position: absolute;
  top: var(--padding-xs);
  right: var(--padding-xs);
  background-color: var(--bg-secondary); /* Slightly different from pre */
  color: var(--text-secondary);
  border: 1px solid var(--border-color);
  padding: 2px 6px; /* Smaller padding */
  border-radius: var(--border-radius-sm);
  cursor: pointer;
  font-size: 10px;
  opacity: 0.6;
  transition: opacity 0.2s, background-color 0.2s;
}
.bubble pre:hover .copy-code-btn { opacity: 1; }
.copy-code-btn:hover {
  background-color: var(--bg-tertiary);
  color: var(--text-primary);
}
.copy-code-btn.copied {
  background-color: var(--bg-success);
  color: var(--text-accent); /* Or a dark text if bg_success is light */
  opacity: 1;
  border-color: var(--bg-success);
}
.bubble code:not(pre code) { /* Inline code */
  background-color: var(--bg-secondary);
  padding: 0.1em 0.3em;
  border-radius: 3px;
  font-family: var(--font-family-main);
  color: var(--text-code);
  border: 1px solid var(--border-color);
}

/* Input Area */
#input-area {
  flex-shrink: 0; /* Prevent input area from shrinking */
  display: flex;
  gap: var(--padding-sm);
  padding: var(--padding-md) var(--padding-lg);
  font-family: var(--font-family-main);
  background: var(--bg-secondary);
  border-top: 1px solid var(--border-color);
}
#prompt, #model-select {
  padding: var(--padding-md);
  font-family: var(--font-family-main);
  font-size: var(--font-size-base);
  border: 1px solid var(--border-color-strong);
  border-radius: var(--border-radius-base);
  background-color: var(--bg-primary); /* Match main bg or slightly lighter */
  color: var(--text-primary);
  line-height: 1.4;
}
#prompt::placeholder {
  color: var(--text-secondary);
}
#prompt {
  flex: 1 1 auto;
  resize: none; /* Keep as none for this layout */
}
#model-select {
  flex: 0 0 auto; /* Don't grow, shrink as needed */
  max-width: 200px; /* Prevent model select from becoming too wide */
}
#send {
  flex: 0 0 auto;
  padding: var(--padding-md) var(--padding-lg);
  font-family: var(--font-family-main);
  font-size: var(--font-size-base);
  border: none;
  border-radius: var(--border-radius-base);
  background: var(--bg-accent);
  color: var(--text-accent);
  cursor: pointer;
  transition: background-color 0.2s;
}
#send:hover { background: var(--bg-accent-hover); }
#send:disabled {
  background: var(--bg-tertiary);
  color: var(--text-secondary);
  cursor: not-allowed;
}

/* Blinking cursor for streaming response */
.message.assistant:not(.thinking) .bubble.streaming-response::after {
  content: '▋';
  animation: blink 1s infinite;
  display: inline-block;
  margin-left: 2px;
  color: var(--text-accent); /* Use accent color for visibility */
}
@keyframes blink {
  0%, 100% { opacity: 1; }
  50% { opacity: 0; }
}

/* --- Responsive Adjustments --- */
@media (max-width: 768px) {
  :root {
    --sidebar-width: 200px; /* Narrower sidebar */
    --font-size-base: 13px; /* Slightly smaller base font */
  }

  .bubble {
    max-width: 90%; /* Allow bubbles to be a bit wider */
  }

  #input-area {
    flex-direction: column; /* Stack input elements */
  }
  #model-select {
    max-width: 100%; /* Allow model select to take full width when stacked */
    margin-bottom: var(--padding-sm);
  }
  #prompt {
    min-height: 60px; /* Ensure prompt has some height when stacked */
  }
  #send {
    width: 100%; /* Full width send button */
  }

  #current-conversation-title {
    max-width: calc(100% - 100px); /* Adjust for smaller clear button */
  }
}

@media (max-width: 480px) {
  /* Removed empty :root ruleset as per lint recommendation */
  /* Example: if you wanted to hide sidebar on very small screens without JS for toggle:
  #sidebar {
    display: none;
  }
  */
  /* For this example, we'll just make it narrower to avoid JS for a toggle */
   #sidebar {
     width: 160px;
   }


  #chat-header {
    padding: var(--padding-sm);
  }
  #current-conversation-title {
    font-size: var(--font-size-base);
  }
  #clear-conversation-btn {
    font-size: 10px; /* Smaller text */
    padding: var(--padding-xs) var(--padding-sm);
  }
}

/* Error Message Styling */
.error-message {
  color: var(--text-error);
  background-color: var(--bg-error);
  padding: var(--padding-md);
  border-radius: var(--border-radius-sm);
  margin-top: var(--padding-md);
  margin-bottom: var(--padding-md); /* Added margin bottom for spacing */
  border: 1px solid var(--text-error);
  font-size: var(--font-size-sm);
}

.message.assistant .bubble.error-bubble {
  background-color: var(--bg-error);
  color: var(--text-error);
  border: 1px solid var(--text-error);
}

/* --- Right Sidebar Styling --- */
#right-sidebar {
  width: 300px; /* Example width */
  height: 100vh; /* Match main content/sidebar height */
  background-color: var(--bg-secondary);
  color: var(--text-primary);
  padding: var(--padding-lg);
  border-left: 1px solid var(--border-color);
  display: flex;
  flex-direction: column;
  flex-shrink: 0; /* Prevent from shrinking */
}

#right-sidebar-tabs {
  display: flex;
  margin-bottom: var(--padding-md);
}

#right-sidebar-tabs .sidebar-tab-button {
  padding: var(--padding-sm) var(--padding-md);
  border: 1px solid var(--border-color);
  background-color: var(--bg-tertiary);
  color: var(--text-secondary);
  cursor: pointer;
  flex-grow: 1;
  text-align: center;
  border-radius: var(--border-radius-sm);
  margin-right: var(--padding-xs); /* Small gap between buttons */
  transition: background-color 0.2s, color 0.2s;
}
#right-sidebar-tabs .sidebar-tab-button:last-child {
  margin-right: 0;
}

#right-sidebar-tabs .sidebar-tab-button:hover {
  background-color: var(--bg-accent-hover);
  color: var(--text-accent);
}

#right-sidebar-tabs .sidebar-tab-button.active {
  background-color: var(--bg-accent);
  color: var(--text-accent);
  border-color: var(--bg-accent-hover);
}

#right-sidebar-content {
  flex-grow: 1;
  overflow-y: auto;
  display: flex; /* To make panels take full height if needed */
  flex-direction: column;
}

#right-sidebar-content .sidebar-panel {
  display: none; /* Hidden by default */
  padding: var(--padding-sm);
  /* border: 1px solid var(--border-color); Removed for now, let's see how it looks */
  border-radius: var(--border-radius-sm);
  flex-grow: 1; /* Allow panel to take available space */
}

#right-sidebar-content .sidebar-panel.active {
  display: block;
}

/* Styling for form elements in Batch Settings panel */
#batch-settings-panel div {
  margin-bottom: var(--padding-md);
}

#batch-settings-panel label {
  display: block;
  margin-bottom: var(--padding-xs);
  color: var(--text-secondary);
  font-size: var(--font-size-sm);
}

#batch-settings-panel input[type="number"],
#batch-settings-panel textarea {
  width: 100%;
  padding: var(--padding-sm);
  background-color: var(--bg-primary);
  color: var(--text-primary);
  border: 1px solid var(--border-color-strong);
  border-radius: var(--border-radius-sm);
  font-family: var(--font-family-main);
  font-size: var(--font-size-base);
}

#batch-settings-panel textarea {
  resize: vertical;
  min-height: 60px;
}

#batch-settings-panel input[type="checkbox"] {
  margin-right: var(--padding-sm);
  vertical-align: middle;
}
/* Align checkbox label better */
#batch-settings-panel input[type="checkbox"] + label {
  display: inline;
  font-size: var(--font-size-base); /* Match other input text */
  color: var(--text-primary);
}

/* --- Right Sidebar Collapsible Styling --- */
.right-sidebar-collapsed {
  display: none !important; /* Important to override other display properties if they exist */
}

#toggle-right-sidebar-btn {
  margin-left: var(--padding-sm);
  padding: var(--padding-sm) var(--padding-md); /* Consistent with other header buttons */
  font-family: var(--font-family-main);
  font-size: var(--font-size-sm); /* Consistent */
  background-color: var(--bg-tertiary);
  color: var(--text-secondary);
  border: 1px solid var(--border-color);
  border-radius: var(--border-radius-sm);
  cursor: pointer;
  transition: background-color 0.2s, color 0.2s;
}

#toggle-right-sidebar-btn:hover {
  background-color: var(--bg-accent-hover);
  color: var(--text-accent);
}

/* Use a flex container for the chat header to allow flexible title sizing */
#chat-header {
  display: flex;
  align-items: center;
  gap: 8px; /* adjust as needed for spacing between title and buttons */
}

/* Allow the title to shrink/grow as needed, but not overflow */
#chat-header #current-conversation-title {
  flex: 1 1 auto;
  min-width: 0;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}
</style>
</head>
<body>
<div id="sidebar">
<a style='font-size:20px;color:#777;padding:20px;text-align:center;'>localllm</a>
<button id="new-conversation-btn">New Conversation</button>
<ul id="conversation-list">
</ul>
</div>
<div id="main-content">
<div id="chat-header">
  <span id="current-conversation-title">New Conversation</span>
  <div> <!-- Wrapper for buttons on the right -->
    <button id="clear-conversation-btn">Clear Messages</button>
    <button id="toggle-right-sidebar-btn" title="Toggle Settings">&rsaquo;</button> <!-- › -->
  </div>
</div>
<div id="chat-log"></div>
<form id="input-area">
<select id="model-select" required>
<option value="">Loading models...</option>
</select>
<input type="text" id="prompt" placeholder="Ask something..." autocomplete="off" required />
<button id="send" type="submit">Send</button>
</form>
</div>
<div id="right-sidebar">
  <div id="right-sidebar-tabs">
    <button id="batch-settings-tab" class="sidebar-tab-button active" data-tab-target="#batch-settings-panel">Batch Settings</button>
    <button id="tab2-tab" class="sidebar-tab-button" data-tab-target="#tab2-panel">Tab 2</button>
    <button id="tab3-tab" class="sidebar-tab-button" data-tab-target="#tab3-panel">Tab 3</button>
    <button id="tab4-tab" class="sidebar-tab-button" data-tab-target="#tab4-panel">Tab 4</button>
  </div>
  <div id="right-sidebar-content">
    <div id="batch-settings-panel" class="sidebar-panel active">
      <div>
        <label for="temp-input">Temperature:</label>
        <input type="number" id="temp-input" name="temp-input" step="0.1" value="0.7">
      </div>
      <div>
        <label for="top-k-input">Top K:</label>
        <input type="number" id="top-k-input" name="top-k-input" step="1" value="40">
      </div>
      <div>
        <label for="top-p-input">Top P:</label>
        <input type="number" id="top-p-input" name="top-p-input" step="0.01" value="0.9">
      </div>
      <div>
        <label for="system-prompt-input">System Prompt:</label>
        <textarea id="system-prompt-input" name="system-prompt-input" rows="3"></textarea>
      </div>
      <div>
        <input type="checkbox" id="temp-random-checkbox" name="temp-random-checkbox">
        <label for="temp-random-checkbox">Temperature Randomization</label>
      </div>
      <div>
        <label for="num-outputs-input">Number of Outputs:</label>
        <input type="number" id="num-outputs-input" name="num-outputs-input" step="1" value="1" min="1">
      </div>
    </div>
    <div id="tab2-panel" class="sidebar-panel">
      <p>Tab 2 Content</p>
    </div>
    <div id="tab3-panel" class="sidebar-panel">
      <p>Tab 3 Content</p>
    </div>
    <div id="tab4-panel" class="sidebar-panel">
      <p>Tab 4 Content</p>
    </div>
  </div>
</div>

<script>
// --- Configuration ---
const OLLAMA_BASE_URL = "http://localhost:11434";
const CONVO_LIST_KEY = 'ollama_convos';
let conversations = {convlist:[], lastmodel:""}; // convunique is largely redundant if ix maps to array index
try
  {
  let convoraw = localStorage.getItem(CONVO_LIST_KEY);
  if (convoraw == null)
    {
    localStorage.setItem(CONVO_LIST_KEY, JSON.stringify(conversations));
    }
  else
    {
    conversations = JSON.parse(convoraw);
    // Ensure new properties exist
    conversations.convlist.forEach(convo => {
        if (!convo.modelName && convo.model) { // Add modelName if missing
            // This is a simple fallback, might not find the exact name if models changed
            convo.modelName = convo.model.split(':')[0];
        }
    });
    // Ensure ix consistency
    conversations.convlist.forEach((convo, index) => {
        convo.ix = index; // Ensure ix is the current array index
    });
    }
  }
catch (e)
  {
  console.error("Error loading conversations from localStorage:", e);
  localStorage.setItem(CONVO_LIST_KEY, JSON.stringify(conversations));
  conversations = {convlist:[], lastmodel:""}; // Reset if error
  }
let currentConvo = null; // Will be set on new convo or load convo

// --- DOM elements ---
const chatLog = document.getElementById("chat-log");
const promptInput = document.getElementById("prompt");
const form = document.getElementById("input-area");
const modelSelect = document.getElementById("model-select");
const sendButton = document.getElementById("send");
const sidebar = document.getElementById("sidebar");
const conversationList = document.getElementById("conversation-list");
const newConversationBtn = document.getElementById("new-conversation-btn");
// --- FEATURE: Chat Header DOM Elements START ---
const currentConversationTitleEl = document.getElementById("current-conversation-title");
const clearConversationBtn = document.getElementById("clear-conversation-btn");
// --- FEATURE: Chat Header DOM Elements END ---

// --- Conversation state ---
let isLoading = false;

// Helper to display model loading errors
function displayModelError(message) {
    const existingError = document.getElementById("model-load-error");
    if (existingError) {
        existingError.remove();
    }
    const errorP = document.createElement("p");
    errorP.id = "model-load-error";
    errorP.className = "error-message";
    errorP.textContent = message;
    // Try to append below modelSelect, fallback to sidebar
    if (modelSelect && modelSelect.parentNode) {
      modelSelect.parentNode.insertBefore(errorP, modelSelect.nextSibling);
    } else {
      sidebar.appendChild(errorP); // Fallback to sidebar
    }
}

async function fetchModels()
  {
  try
    {
    // Clear previous error messages if any
    const existingError = document.getElementById("model-load-error");
    if (existingError) {
        existingError.remove();
    }

    const response = await fetch(`${OLLAMA_BASE_URL}/api/tags`);
    if (!response.ok)
      {
      const statusText = response.statusText || "Unknown server error";
      modelSelect.innerHTML = '<option value="">Error loading models</option>'; // Keep basic select fallback
      // Note: displayModelError will be called in the catch block
      throw new Error(`Failed to fetch models: ${response.status} ${statusText}`);
      }
    const data = await response.json();
    const models = data.models || [];
    modelSelect.innerHTML = '<option value="">Select a model...</option>'; // Clear "loading"
    if (models.length === 0)
      {
      modelSelect.innerHTML = '<option value="">No models found</option>';
      // Optionally, display a message using displayModelError if this is considered an error condition
      // displayModelError("No models found on the Ollama server.");
      return; // Still return as no models to select
      }
    models.forEach(model =>
      {
      const option = document.createElement("option");
      option.value = model.model;
      option.textContent = model.name;
      modelSelect.appendChild(option);
      }
    );

    if (models.length > 0)
      {
      if (conversations && conversations.lastmodel != "" && modelSelect.querySelector(`option[value="${conversations.lastmodel}"]`))
        {
        modelSelect.value = conversations.lastmodel;
        }
      else if (models[0])
        {
        modelSelect.value = models[0].model;
        conversations.lastmodel = models[0].model;
        }
      }
    // After models are loaded, initiate a new conversation or load existing
    if (conversations.convlist.length > 0)
      {
      loadConversation(conversations.convlist.length - 1);
      }
    else
      {
      startNewConversation();
      }
    renderConversationList();
    }
  catch (error)
    {
    console.error("Error fetching models:", error);
    modelSelect.innerHTML = '<option value="">Error loading models</option>'; // Keep basic fallback in select
    if (error.message.includes("Failed to fetch models")) { // Network or server status error
        displayModelError(`Could not connect to Ollama server at ${OLLAMA_BASE_URL} to load models. Details: ${error.message}. Please ensure Ollama is running and accessible.`);
    } else { // Other errors
        displayModelError(`An unexpected error occurred while loading models: ${error.message}`);
    }
    // Attempt to allow UI to function somewhat even if models fail
    startNewConversation();
    renderConversationList();
    }
  }

document.addEventListener('DOMContentLoaded', fetchModels);

function saveConvo()
  {
  // Ensure all convos in convlist have up-to-date modelName if currentConvo does
  if (currentConvo && currentConvo.modelName && currentConvo.ix !== -1 && conversations.convlist[currentConvo.ix]) {
    conversations.convlist[currentConvo.ix].modelName = currentConvo.modelName;
    conversations.convlist[currentConvo.ix].model = currentConvo.model;
  }
  localStorage.setItem(CONVO_LIST_KEY, JSON.stringify(conversations));
  renderConversationList(); // Update sidebar after saving
  }

function startNewConversation()
  {
    const selectedModelValue = modelSelect.value;
    const selectedModelOption = modelSelect.options[modelSelect.selectedIndex];
    const selectedModelName = selectedModelOption ? selectedModelOption.text : (selectedModelValue ? selectedModelValue.split(':')[0] : "Unknown Model");


  currentConvo = {
      ix: -1,
      name: "New Conversation",
      model: selectedModelValue,
      modelName: selectedModelName, // FEATURE: Store model name
      messages: [],
      tokenct: 0
    };
  chatLog.innerHTML = ''; // Clear chat log
  promptInput.value = '';
  promptInput.placeholder = "Ask something...";
  setLoadingState(false);
  // --- FEATURE: Chat Header Update START ---
  currentConversationTitleEl.textContent = currentConvo.name;
  // --- FEATURE: Chat Header Update END ---
  updateActiveConversationItem();
  }

function initSaveConvo() // Call this when a new conversation gets its first messages
  {
  if (currentConvo.ix === -1) // If it's a brand new, unsaved conversation
    {
    currentConvo.ix = conversations.convlist.length; // Assign new index
    // Update name from first user message if available
    if (currentConvo.messages.length > 0 && currentConvo.messages[0].role === 'user') {
        let firstMsg = currentConvo.messages[0].content;
        currentConvo.name = firstMsg.substring(0, 30) + (firstMsg.length > 30 ? "..." : "");
    } else {
        currentConvo.name = "Conversation " + (currentConvo.ix + 1); // Fallback name
    }

    // Ensure model and modelName are set
    if (!currentConvo.model && modelSelect.value) {
        currentConvo.model = modelSelect.value;
        currentConvo.modelName = modelSelect.options[modelSelect.selectedIndex].text;
    } else if (currentConvo.model && !currentConvo.modelName) {
        // Attempt to find model name if only model ID is present
        const opt = Array.from(modelSelect.options).find(o => o.value === currentConvo.model);
        currentConvo.modelName = opt ? opt.text : currentConvo.model.split(':')[0];
    }

    conversations.convlist.push(currentConvo);
    }
  else if (currentConvo.ix >= 0 && currentConvo.ix < conversations.convlist.length) // Existing conversation
    {
    conversations.convlist[currentConvo.ix] = currentConvo;
    }
  // --- FEATURE: Chat Header Update START ---
  currentConversationTitleEl.textContent = currentConvo.name;
  // --- FEATURE: Chat Header Update END ---
  saveConvo();
  }


function appendMessage(role, content, wrapperExtraClasses = [], bubbleExtraClasses = [])
  {
  const wrapper = document.createElement("div");
  wrapper.className = `message ${role} ${wrapperExtraClasses.join(' ')}`.trim();
  const bubble = document.createElement("div");
  bubble.className = `bubble ${bubbleExtraClasses.join(' ')}`.trim();
  bubble.innerHTML = formatMessage(content);

  if (role === "user" || role === "assistant")
    {
    // Make editable functionality can be complex with markdown, consider removing or simplifying
    // bubble.contentEditable = "true";
    // bubble.setAttribute('data-original-content', content);
    // bubble.addEventListener('blur', function() { /* ... edit logic ... */ });
    }
  wrapper.appendChild(bubble);
  chatLog.appendChild(wrapper);
  chatLog.scrollTop = chatLog.scrollHeight;

  // --- FEATURE: Copy Code Button Logic START ---
  if (role === "assistant" || role === "thinking") { // Also add to thinking if it might contain pre
    const preBlocks = bubble.querySelectorAll("pre");
    preBlocks.forEach(pre => {
        const codeEl = pre.querySelector('code');
        if (!codeEl) return; // No code element found

        const copyBtn = document.createElement("button");
        copyBtn.textContent = "Copy";
        copyBtn.className = "copy-code-btn";
        copyBtn.addEventListener("click", () => {
            navigator.clipboard.writeText(codeEl.innerText)
                .then(() => {
                    copyBtn.textContent = "Copied!";
                    copyBtn.classList.add("copied");
                    setTimeout(() => {
                        copyBtn.textContent = "Copy";
                        copyBtn.classList.remove("copied");
                    }, 2000);
                })
                .catch(err => {
                    console.error("Failed to copy code:", err);
                    copyBtn.textContent = "Error";
                     setTimeout(() => { copyBtn.textContent = "Copy"; }, 2000);
                });
        });
        // Check if pre already has a copy button (e.g. during streaming update)
        if (!pre.querySelector('.copy-code-btn')) {
            pre.appendChild(copyBtn);
        }
    });
  }
  // --- FEATURE: Copy Code Button Logic END ---


  if (currentConvo && currentConvo.messages == null) // Should not happen if currentConvo is initialized correctly
    {
    initSaveConvo();
    }
  // Assign a unique tag for easy retrieval during edits (if re-enabled)
  if (currentConvo && currentConvo.messages) { // Ensure currentConvo and messages exist
    bubble.tag = currentConvo.messages.length; // This tag might be problematic if messages are deleted/edited later
  }
  return bubble;
  }

function formatMessage(text) // Basic XSS protection, ensure robustness if used in wider contexts
  {
  let escapedText = text.replace(/&/g, '&amp;')
  .replace(/</g, '&lt;')
  .replace(/>/g, '&gt;')
  .replace(/"/g, '&quot;')
  .replace(/'/g, "&apos;");

  // Improved Markdown for code blocks, bold, italics, inline code
  escapedText = escapedText.replace(/```(\w*)\n([\s\S]*?)```|```([\s\S]*?)```/g, (match, lang, codeWithLang, codeWithoutLang) =>
    {
    const code = codeWithLang || codeWithoutLang;
    // Re-escape inside code block to prevent HTML injection if original text wasn't perfectly clean
    const escapedCode = code.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
    const languageClass = lang ? ` class="language-${lang}"` : "";
    return `<pre><code${languageClass}>${escapedCode.trim()}</code></pre>`;
    }
  );
  escapedText = escapedText.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
  escapedText = escapedText.replace(/\*(.*?)\*/g, '<em>$1</em>');
  escapedText = escapedText.replace(/`(.*?)`/g, '<code>$1</code>');
  return escapedText;
  }

function setLoadingState(loading)
  {
  isLoading = loading;
  sendButton.disabled = loading;
  promptInput.disabled = loading;
  sendButton.textContent = loading ? "Responding" : "Send";
  }

async function queryOllama(userPrompt)
  {
  if (!currentConvo || !currentConvo.model)
    {
    appendMessage("assistant", "Please select a model first or start a new conversation.");
    return;
    }

    // Read values from Batch Settings panel (moved to top of function as per plan)
    const temperatureInput = document.getElementById('temp-input');
    const topKInput = document.getElementById('top-k-input');
    const topPInput = document.getElementById('top-p-input');
    const systemPromptInput = document.getElementById('system-prompt-input');
    const randomizeTemperatureCheckbox = document.getElementById('temp-random-checkbox');
    const numOutputsInput = document.getElementById('num-outputs-input');

    const systemPrompt = systemPromptInput ? systemPromptInput.value.trim() : "";
    const randomizeTemperature = randomizeTemperatureCheckbox ? randomizeTemperatureCheckbox.checked : false;
    const numOutputs = numOutputsInput ? (parseInt(numOutputsInput.value) || 1) : 1;

    const ollamaOptions = {};
    if (temperatureInput && temperatureInput.value !== "" && !isNaN(parseFloat(temperatureInput.value))) {
      ollamaOptions.temperature = parseFloat(temperatureInput.value);
    } else {
      ollamaOptions.temperature = 0.7; // Default if not set or invalid
    }
    if (topKInput && topKInput.value !== "" && !isNaN(parseInt(topKInput.value))) {
      ollamaOptions.top_k = parseInt(topKInput.value);
    }
    if (topPInput && topPInput.value !== "" && !isNaN(parseFloat(topPInput.value))) {
      ollamaOptions.top_p = parseFloat(topPInput.value);
    }

  // setLoadingState(true); // Moved inside single/batch logic

  if (currentConvo.ix === -1 && currentConvo.messages.length === 0)
    {
    currentConvo.messages.push({ role: "user", content: userPrompt });
    initSaveConvo();
    }
  else
    {
    // Check if the last message is the same as the current userPrompt to avoid double-adding on retry/edit
    if (currentConvo.messages.length === 0 || currentConvo.messages[currentConvo.messages.length -1].role !== 'user' || currentConvo.messages[currentConvo.messages.length -1].content !== userPrompt ) {
        currentConvo.messages.push({ role: "user", content: userPrompt });
    }
    if (currentConvo.ix === -1) {
        initSaveConvo();
    }
    }

if (numOutputs <= 1) {
    // --- SINGLE OUTPUT LOGIC ---
    setLoadingState(true);

    const messagesForApiCall = [...currentConvo.messages];
    if (systemPrompt) {
        if (messagesForApiCall.length > 0 && messagesForApiCall[0].role === 'system') {
            if (messagesForApiCall[0].content !== systemPrompt) { // Only update if different
                messagesForApiCall[0] = { role: "system", content: systemPrompt };
            }
        } else {
            messagesForApiCall.unshift({ role: "system", content: systemPrompt });
        }
    } else { // No system prompt, ensure none is at the start of the array for API call
        if (messagesForApiCall.length > 0 && messagesForApiCall[0].role === 'system') {
            messagesForApiCall.shift();
        }
    }

    const queryBody = {
        model: currentConvo.model,
        messages: messagesForApiCall,
        stream: true,
    };
    if (Object.keys(ollamaOptions).length > 0) { // Add options if they exist
      queryBody.options = ollamaOptions;
    }


    let assistantResponseBubble = null;
    let fullAssistantResponse = "";
    let curAssistantResponse = "";

    try {
        const response = await fetch(`${OLLAMA_BASE_URL}/api/chat`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(queryBody)
        });

        if (!response.ok) {
            const errorText = await response.text(); // Try to get more details
            throw new Error(`Ollama API error: ${response.status} ${response.statusText} - ${errorText}`);
        }

        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        let buffer = "";

        while (true) { // Main streaming loop for single response
            const { value, done } = await reader.read();
            if (done) break;
            buffer += decoder.decode(value, { stream: true });
            let eolIndex;
            while ((eolIndex = buffer.indexOf('\n')) >= 0) {
                const line = buffer.substring(0, eolIndex).trim();
                buffer = buffer.substring(eolIndex + 1);
                if (line) {
                    try {
                        const parsedChunk = JSON.parse(line);
                        if (parsedChunk.message && parsedChunk.message.content) {
                            let contentChunk = parsedChunk.message.content;
                            if (contentChunk === "<think>") {
                                if (assistantResponseBubble && assistantResponseBubble.parentElement && !assistantResponseBubble.parentElement.classList.contains('thinking')) {
                                    assistantResponseBubble.parentElement.remove();
                                }
                                assistantResponseBubble = appendMessage("thinking", "");
                                sendButton.textContent = "Thinking...";
                                curAssistantResponse = "";
                            } else if (contentChunk === "</think>") {
                                if (assistantResponseBubble && assistantResponseBubble.parentElement && assistantResponseBubble.parentElement.classList.contains('thinking')) {
                                    assistantResponseBubble.parentElement.remove();
                                }
                                assistantResponseBubble = appendMessage("assistant", "");
                                if(assistantResponseBubble) assistantResponseBubble.classList.add("streaming-response");
                                sendButton.textContent = "Responding...";
                                curAssistantResponse = "";
                            } else {
                                if (!assistantResponseBubble || (assistantResponseBubble.parentElement && assistantResponseBubble.parentElement.classList.contains('thinking'))) {
                                     if (assistantResponseBubble && assistantResponseBubble.parentElement && assistantResponseBubble.parentElement.classList.contains('thinking')) {
                                         assistantResponseBubble.parentElement.remove();
                                     }
                                     assistantResponseBubble = appendMessage("assistant", "");
                                     if(assistantResponseBubble) assistantResponseBubble.classList.add("streaming-response");
                                     curAssistantResponse = "";
                                }
                                curAssistantResponse += contentChunk;
                                if(assistantResponseBubble) assistantResponseBubble.innerHTML = formatMessage(curAssistantResponse);
                                const preBlocks = assistantResponseBubble ? assistantResponseBubble.querySelectorAll("pre") : [];
                                preBlocks.forEach(pre => {
                                    if (pre.querySelector('.copy-code-btn')) return;
                                    const codeEl = pre.querySelector('code');
                                    if (!codeEl) return;
                                    const copyBtn = document.createElement("button"); copyBtn.textContent = "Copy"; copyBtn.className = "copy-code-btn";
                                    copyBtn.addEventListener("click", () => navigator.clipboard.writeText(codeEl.innerText).then(() => { copyBtn.textContent = "Copied!"; copyBtn.classList.add("copied"); setTimeout(() => { copyBtn.textContent = "Copy"; copyBtn.classList.remove("copied"); }, 2000); }).catch(err => { console.error("Failed to copy code:", err); copyBtn.textContent = "Error"; setTimeout(() => { copyBtn.textContent = "Copy"; }, 2000); }) );
                                    pre.appendChild(copyBtn);
                                });
                                if(assistantResponseBubble) assistantResponseBubble.scrollIntoView({ behavior: 'smooth', block: 'end' });
                            }
                            fullAssistantResponse += contentChunk;
                        } else if (parsedChunk.done && parsedChunk.total_duration) {
                            // Ollama stream finished
                        }
                    } catch (e) { console.warn("Failed to parse JSON chunk (single):", line, e); }
                }
            }
        }
        if (buffer.trim()) { // Process any remaining buffer content after stream ends
            try {
                const parsedChunk = JSON.parse(buffer.trim());
                if (parsedChunk.message && parsedChunk.message.content) {
                    let contentChunk = parsedChunk.message.content;
                    // Ensure it's not a stray think/endthink tag if it's the only thing left
                    if (contentChunk !== "<think>" && contentChunk !== "</think>") {
                        curAssistantResponse += contentChunk;
                        fullAssistantResponse += contentChunk; // Add to full response
                        // Update bubble display if it exists and is not a thinking bubble
                        if (assistantResponseBubble && assistantResponseBubble.parentElement && !assistantResponseBubble.parentElement.classList.contains('thinking')) {
                             if(assistantResponseBubble) assistantResponseBubble.innerHTML = formatMessage(curAssistantResponse);
                        } else if (!assistantResponseBubble && curAssistantResponse) { // If no bubble yet, create one
                            assistantResponseBubble = appendMessage("assistant", formatMessage(curAssistantResponse));
                        } else if (assistantResponseBubble && curAssistantResponse) { // If it was a thinking bubble, replace it
                            if(assistantResponseBubble.parentElement && assistantResponseBubble.parentElement.classList.contains('thinking')){
                                assistantResponseBubble.parentElement.remove();
                                assistantResponseBubble = appendMessage("assistant", formatMessage(curAssistantResponse));
                            } else {
                                // Fallback, though this case should be covered by the first condition
                                assistantResponseBubble.innerHTML = formatMessage(curAssistantResponse);
                            }
                        }
                    }
                }
            } catch(e) { console.warn("Failed to parse final JSON buffer (single):", buffer.trim(), e); }
        }

    } catch (err) {
        console.error("Error querying Ollama (single):", err);
        if (assistantResponseBubble && assistantResponseBubble.parentElement && !assistantResponseBubble.parentElement.classList.contains('thinking')) {
            if(assistantResponseBubble) assistantResponseBubble.innerHTML = formatMessage(`Error: ${err.message}`);
            if(assistantResponseBubble) assistantResponseBubble.classList.add('error-bubble');
        } else {
             if (assistantResponseBubble && assistantResponseBubble.parentElement && assistantResponseBubble.parentElement.classList.contains('thinking')) {
                assistantResponseBubble.parentElement.remove();
             }
            appendMessage("assistant", `Error: ${err.message}`, [], ['error-bubble']);
        }
        fullAssistantResponse = `Error: ${err.message}`;
    } finally {
        if (assistantResponseBubble) assistantResponseBubble.classList.remove("streaming-response");
        // Save the full response to conversation history
        const cleanFullResponse = fullAssistantResponse.replace(/<\/?think>/g, '').trim();
        if (cleanFullResponse) { // Only push if there's actual content
            currentConvo.messages.push({ role: "assistant", content: cleanFullResponse });
        }
        currentConvo.tokenct = estimateTokensInConversation(currentConvo.messages);
        promptInput.placeholder = "Ask something.. (" + currentConvo.tokenct + " tokens so far)";
        initSaveConvo();
        setLoadingState(false);
        promptInput.focus();
    }

} else {
    // --- BATCH OUTPUT LOGIC ---
    setLoadingState(true);
    const userPromptForBatch = userPrompt; // Store the original user prompt for batch use

    const promises = [];
    const allBatchExecutionDetails = []; // To store options like temperature for each item

    for (let i = 0; i < numOutputs; i++) {
        let currentTemperature = ollamaOptions.temperature; // Start with base or user-set temperature
        if (randomizeTemperature) {
            // Generate a random temperature between 0.0 and 1.0, with two decimal places
            currentTemperature = parseFloat(Math.random().toFixed(2));
             // Ensure it's within typical bounds, though Ollama might clamp anyway
            if (currentTemperature > 1.0) currentTemperature = 1.0;
            if (currentTemperature < 0.0) currentTemperature = 0.0;
        }
        // Create a new options object for this specific batch item
        const batchItemOptions = { ...ollamaOptions, temperature: currentTemperature };

        // Prepare messages for this batch item: system (if any) + user prompt
        const messagesForBatchItem = [];
        if (systemPrompt) {
            messagesForBatchItem.push({ role: "system", content: systemPrompt });
        }
        messagesForBatchItem.push({ role: "user", content: userPromptForBatch }); // Use the stored user prompt

        allBatchExecutionDetails.push({ options: batchItemOptions }); // Store for later display

        promises.push(fetch(`${OLLAMA_BASE_URL}/api/chat`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
                model: currentConvo.model,
                messages: messagesForBatchItem,
                stream: true, // Each batch item will stream individually
                options: batchItemOptions
            })
        }));
    }

    // Process all fetch promises
    const results = await Promise.allSettled(promises);
    let allBatchAssistantResponses = []; // To store all successful assistant responses for history

    for (let idx = 0; idx < results.length; idx++) {
        const result = results[idx];
        const batchItemNumber = idx + 1;
        const execDetails = allBatchExecutionDetails[idx]; // Get corresponding execution details
        const tempDisplay = execDetails.options.temperature.toFixed(2);
        const initialBubbleText = `Response ${batchItemNumber}/${numOutputs} (Temp: ${tempDisplay}): Loading...`;

        if (result.status === "fulfilled") {
            const response = result.value; // This is the Response object

            if (!response.ok) {
                const errorText = await response.text();
                console.error(`Batch item ${batchItemNumber} API error ${response.status}:`, errorText);
                appendMessage("assistant", `Error for Response ${batchItemNumber}/${numOutputs}: ${response.statusText} - ${errorText}`, [], ['error-bubble', 'batch-response-item']);
                allBatchAssistantResponses.push({ role: "assistant", content: `API Error for item ${batchItemNumber}: ${errorText}` });
                continue; // Move to the next promise result
            }

            // Create a bubble for this batch item's response
            let assistantResponseBubble = appendMessage("assistant", initialBubbleText, [], ['batch-response-item']);
            if(assistantResponseBubble) assistantResponseBubble.classList.add("streaming-response");

            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            let buffer = "";
            let fullItemResponseContent = ""; // Content for this item's history
            let currentDisplayContent = ""; // Content for this item's bubble (without prefix)

            try {
                while (true) {
                    const { value, done } = await reader.read();
                    if (done) break;
                    buffer += decoder.decode(value, { stream: true });
                    let eolIndex;
                    while ((eolIndex = buffer.indexOf('\n')) >= 0) {
                        const line = buffer.substring(0, eolIndex).trim();
                        buffer = buffer.substring(eolIndex + 1);
                        if (line) {
                            try {
                                const parsedChunk = JSON.parse(line);
                                if (parsedChunk.message && parsedChunk.message.content) {
                                    let contentChunk = parsedChunk.message.content;
                                    // Skip think tags for batch display simplicity for now
                                    if (contentChunk === "<think>" || contentChunk === "</think>") continue;

                                    fullItemResponseContent += contentChunk;
                                    currentDisplayContent += contentChunk;
                                    // Update the bubble with the prefix and new content
                                    if(assistantResponseBubble) assistantResponseBubble.innerHTML = formatMessage(`Response ${batchItemNumber}/${numOutputs} (Temp: ${tempDisplay}): ` + currentDisplayContent);
                                    // Re-add copy buttons if the bubble content is re-rendered
                                    const preBlocks = assistantResponseBubble ? assistantResponseBubble.querySelectorAll("pre") : [];
                                    preBlocks.forEach(pre => {
                                        if (pre.querySelector('.copy-code-btn')) return;
                                        const codeEl = pre.querySelector('code');
                                        if (!codeEl) return;
                                        const copyBtn = document.createElement("button"); copyBtn.textContent = "Copy"; copyBtn.className = "copy-code-btn";
                                        copyBtn.addEventListener("click", () => navigator.clipboard.writeText(codeEl.innerText).then(() => { copyBtn.textContent = "Copied!"; copyBtn.classList.add("copied"); setTimeout(() => { copyBtn.textContent = "Copy"; copyBtn.classList.remove("copied"); }, 2000); }).catch(err => { console.error("Failed to copy code:", err); copyBtn.textContent = "Error"; setTimeout(() => { copyBtn.textContent = "Copy"; }, 2000); }) );
                                        pre.appendChild(copyBtn);
                                    });
                                    if(assistantResponseBubble) assistantResponseBubble.scrollIntoView({ behavior: 'smooth', block: 'end' });
                                }
                            } catch (e) { console.warn("Failed to parse JSON chunk (batch item):", line, e); }
                        }
                    }
                }
                 // Process any remaining buffer content for this item
                 if (buffer.trim()) {
                    try {
                       const parsedChunk = JSON.parse(buffer.trim());
                       if (parsedChunk.message && parsedChunk.message.content) {
                            let contentChunk = parsedChunk.message.content;
                            if (contentChunk !== "<think>" && contentChunk !== "</think>") { // Skip think tags
                                fullItemResponseContent += contentChunk;
                                currentDisplayContent += contentChunk;
                            }
                       }
                    } catch(e) { console.warn("Failed to parse final JSON buffer (batch item):", buffer.trim(), e); }
                }

                // Final update for this item's bubble
                if(assistantResponseBubble) assistantResponseBubble.innerHTML = formatMessage(`Response ${batchItemNumber}/${numOutputs} (Temp: ${tempDisplay}): ` + currentDisplayContent);
                if(assistantResponseBubble) assistantResponseBubble.classList.remove("streaming-response");
                const cleanItemResponse = fullItemResponseContent.replace(/<\/?think>/g, '').trim();
                if (cleanItemResponse) { // Add to history if contentful
                    allBatchAssistantResponses.push({ role: "assistant", content: cleanItemResponse });
                }

            } catch (streamError) {
                console.error(`Streaming error for batch item ${batchItemNumber}:`, streamError);
                if(assistantResponseBubble) {
                    assistantResponseBubble.innerHTML = formatMessage(`Response ${batchItemNumber}/${numOutputs} (Temp: ${tempDisplay}): Error during streaming - ${streamError.message}`);
                    assistantResponseBubble.classList.add('error-bubble');
                    assistantResponseBubble.classList.remove("streaming-response");
                }
                allBatchAssistantResponses.push({role: "assistant", content: `Streaming Error for item ${batchItemNumber}: ${streamError.message}`});
            }

        } else { // Promise was rejected (e.g., network error before fetch completes)
            console.error(`Batch item ${batchItemNumber} fetch failed:`, result.reason);
            appendMessage("assistant", `Fetch Error for Response ${batchItemNumber}/${numOutputs}: ${result.reason.message}`, [], ['error-bubble', 'batch-response-item']);
            allBatchAssistantResponses.push({role: "assistant", content: `Fetch Error for item ${batchItemNumber}: ${result.reason.message}`});
        }
    }

    // After all batch items are processed, update conversation history
    currentConvo.messages.push(...allBatchAssistantResponses);
    currentConvo.tokenct = estimateTokensInConversation(currentConvo.messages);
    promptInput.placeholder = "Ask something.. (" + currentConvo.tokenct + " tokens so far)";
    initSaveConvo();
    setLoadingState(false);
    promptInput.focus();
}
  }

function estimateTokensInConversation(messageHistory)
  {
  if (!Array.isArray(messageHistory)) return 0;
  let totalCharacters = 0;
  messageHistory.forEach(message => {
    if (message && typeof message.content === 'string') totalCharacters += message.content.length;
  });
  return Math.ceil(totalCharacters / 4); // Rough estimate
  }

// Edit bubble functions (currently disabled in appendMessage, can be re-enabled if desired)
// function handleUserBubbleEdit(bubbleElement, newContent) { /* ... */ }
// function handleAssistantBubbleEdit(bubbleElement, newContent) { /* ... */ }

// --- Conversation List Management ---
function renderConversationList()
  {
  conversationList.innerHTML = ''; // Clear existing list
  for (var i = conversations.convlist.length - 1; i >= 0; i--) // Iterate backwards to show newest first
    {
    const convo = conversations.convlist[i];
    if (!convo) continue; // Skip if convo is undefined (e.g. after a bad delete)

    const container = document.createElement("div");
    container.className = "conversation-item-container";
    container.dataset.index = convo.ix; // Use the stored ix

    const nameSpan = document.createElement("span");
    nameSpan.className = "conversation-name";
    let displayName = convo.name || `Conversation ${convo.ix + 1}`;
    // --- FEATURE: Indicate Model in Sidebar START ---
    const modelDisplayName = convo.modelName || (convo.model ? convo.model.split(':')[0] : 'N/A');
    nameSpan.textContent = `${displayName}`;
    const modelSpan = document.createElement("span");
    modelSpan.className = "conversation-model";
    modelSpan.textContent = `(${modelDisplayName})`;
    nameSpan.appendChild(modelSpan);
    // --- FEATURE: Indicate Model in Sidebar END ---

    nameSpan.addEventListener('click', () => loadConversation(convo.ix));
    container.appendChild(nameSpan);

    const actionsDiv = document.createElement("div");
    actionsDiv.className = "conversation-actions";

    // --- FEATURE: Rename Conversation START ---
    const renameBtn = document.createElement("button");
    renameBtn.innerHTML = "&#9998;"; // Pencil icon
    renameBtn.title = "Rename conversation";
    renameBtn.addEventListener('click', (e) => {
        e.stopPropagation(); // Prevent loadConversation
        promptRenameConversation(convo.ix, nameSpan, container);
    });
    actionsDiv.appendChild(renameBtn);
    // --- FEATURE: Rename Conversation END ---

    // --- FEATURE: Delete Conversation Button START ---
    const deleteBtn = document.createElement("button");
    deleteBtn.innerHTML = "&times;"; // X icon
    deleteBtn.title = "Delete conversation";
    deleteBtn.addEventListener('click', (e) => {
        e.stopPropagation(); // Prevent loadConversation from firing
        deleteConversation(convo.ix);
    });
    actionsDiv.appendChild(deleteBtn);
    // --- FEATURE: Delete Conversation Button END ---
    container.appendChild(actionsDiv);
    conversationList.appendChild(container);
    }
  updateActiveConversationItem();
  }

// --- FEATURE: Rename Conversation START ---
function promptRenameConversation(convoIndex, nameSpanElement, containerElement) {
    const currentName = conversations.convlist[convoIndex].name;
    const input = document.createElement('input');
    input.type = 'text';
    input.value = currentName;
    input.className = 'rename-input'; // Add class for styling

    // Temporarily hide the model span during rename
    const modelSpan = nameSpanElement.querySelector('.conversation-model');
    if (modelSpan) modelSpan.style.display = 'none';

    nameSpanElement.innerHTML = ''; // Clear the span
    nameSpanElement.appendChild(input);
    input.focus();
    input.select();

    const saveRename = () => {
        const newName = input.value.trim();
        if (newName && newName !== currentName) {
            conversations.convlist[convoIndex].name = newName;
            if (currentConvo && currentConvo.ix === convoIndex) {
                currentConvo.name = newName;
                currentConversationTitleEl.textContent = newName;
            }
            saveConvo(); // This will re-render the list
        } else {
            // If name didn't change or is empty, revert to old display
            nameSpanElement.textContent = currentName;
            if (modelSpan) {
                nameSpanElement.appendChild(modelSpan); // Re-add model span
                modelSpan.style.display = ''; // Make it visible again
            }
        }
         // Ensure the container is clickable again if it was part of the nameSpan
        if (!containerElement.hasAttribute('listenerOnClick')) { // Avoid adding multiple listeners
            nameSpanElement.addEventListener('click', () => loadConversation(convoIndex));
            containerElement.setAttribute('listenerOnClick','true');
        }
    };

    input.addEventListener('blur', saveRename);
    input.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
            input.blur(); // Triggers saveRename
        } else if (e.key === 'Escape') {
            input.value = currentName; // Revert
            input.blur(); // Triggers saveRename with old name
        }
    });
}
// --- FEATURE: Rename Conversation END ---

// --- FEATURE: Delete Conversation Logic START ---
function deleteConversation(indexToDelete) {
    const convoName = conversations.convlist[indexToDelete]?.name || `Conversation ${indexToDelete + 1}`;
    if (!confirm(`Are you sure you want to delete "${convoName}"?`)) {
        return;
    }

    conversations.convlist.splice(indexToDelete, 1);

    // Re-index conversations and rebuild convunique
    const newConvUnique = {};
    conversations.convlist.forEach((convo, newIndex) => {
        convo.ix = newIndex;
        newConvUnique[newIndex] = convo;
    });
    conversations.convunique = newConvUnique;

    if (currentConvo && currentConvo.ix === indexToDelete) {
        // If current conversation was deleted, load the newest or start fresh
        if (conversations.convlist.length > 0) {
            loadConversation(conversations.convlist.length - 1);
        } else {
            startNewConversation();
        }
    } else if (currentConvo && currentConvo.ix > indexToDelete) {
        // If current convo was after the deleted one, its index needs update
        currentConvo.ix--;
    }
    saveConvo(); // This also calls renderConversationList
}
// --- FEATURE: Delete Conversation Logic END ---


function loadConversation(index)
  {
  if (isLoading) return;
  if (index < 0 || index >= conversations.convlist.length) {
    console.warn("Attempted to load invalid conversation index:", index);
    if (conversations.convlist.length > 0) { // Fallback to last convo
        loadConversation(conversations.convlist.length - 1);
    } else {
        startNewConversation(); // Or start new if no convos left
    }
    return;
  }

  currentConvo = conversations.convlist[index];
  chatLog.innerHTML = ''; // Clear current chat
  (currentConvo.messages || []).forEach((message, i) => // Ensure messages array exists
    {
    const bubble = appendMessage(message.role, message.content);
    // bubble.tag = i; // Tagging for edit, ensure edit logic handles it if re-enabled
    }
  );
  promptInput.placeholder = `Ask something.. (${currentConvo.tokenct || 0} tokens so far)`;
  if (currentConvo.model && modelSelect.querySelector(`option[value="${currentConvo.model}"]`)) {
    modelSelect.value = currentConvo.model;
  } else if (conversations.lastmodel && modelSelect.querySelector(`option[value="${conversations.lastmodel}"]`)) {
    modelSelect.value = conversations.lastmodel; // Fallback to last used model
    currentConvo.model = conversations.lastmodel;
    currentConvo.modelName = modelSelect.options[modelSelect.selectedIndex]?.text || currentConvo.model.split(':')[0];
  } else if (modelSelect.options.length > 1) { // More than "Select a model..."
    modelSelect.selectedIndex = 1; // Fallback to first available model
    currentConvo.model = modelSelect.value;
    currentConvo.modelName = modelSelect.options[1]?.text || currentConvo.model.split(':')[0];
  }


  // --- FEATURE: Chat Header Update START ---
  currentConversationTitleEl.textContent = currentConvo.name;
  // --- FEATURE: Chat Header Update END ---
  updateActiveConversationItem();
  chatLog.scrollTop = chatLog.scrollHeight;
  }

function updateActiveConversationItem()
  {
  document.querySelectorAll('.conversation-item-container').forEach(item =>
    {
    item.classList.remove('active');
    }
  );
  if (currentConvo && currentConvo.ix !== -1 && currentConvo.ix < conversations.convlist.length) // Check index validity
    {
    const activeItem = document.querySelector(`.conversation-item-container[data-index="${currentConvo.ix}"]`);
    if (activeItem)
      {
      activeItem.classList.add('active');
      }
    }
  }

// --- Event Listeners ---
form.addEventListener("submit", async (e) =>
  {
  e.preventDefault();
  if (isLoading) return;
  const promptText = promptInput.value.trim(); // Renamed to avoid conflict
  if (!promptText) return;

  // Ensure currentConvo is initialized
  if (!currentConvo) startNewConversation();

  appendMessage("user", promptText);
  promptInput.value = "";
  promptInput.focus();

  await queryOllama(promptText);
  }
);

// --- FEATURE: Keyboard Shortcut for Sending START ---
promptInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) {
        e.preventDefault();
        form.dispatchEvent(new Event('submit', { cancelable: true, bubbles: true }));
    }
});
// --- FEATURE: Keyboard Shortcut for Sending END ---

modelSelect.addEventListener("change", (e) =>
  {
  const newModel = e.target.value;
  const newModelName = e.target.options[e.target.selectedIndex].text;

  if (!currentConvo) startNewConversation(); // Initialize if null

  if (currentConvo.model !== newModel)
    {
    const oldModelName = currentConvo.modelName || currentConvo.model || "no model";
    appendMessage("thinking", `Model switched from ${oldModelName} to ${newModelName}`); // "thinking" type for system messages
    currentConvo.model = newModel;
    currentConvo.modelName = newModelName; // FEATURE: Store model name
    conversations.lastmodel = newModel; // Update last selected model globally
    if (currentConvo.ix !== -1) { // If it's an existing, saved conversation
        initSaveConvo(); // This will save the updated currentConvo (with new model) to the list
    } else {
        // For a new, unsaved conversation, just update its properties.
        // It will be fully saved by initSaveConvo() when the first message is sent.
        // However, we should save `conversations.lastmodel`.
        localStorage.setItem(CONVO_LIST_KEY, JSON.stringify(conversations)); // Save just the global state
    }
    }
  }
);

newConversationBtn.addEventListener('click', startNewConversation);

// --- FEATURE: Clear Current Conversation Messages START ---
clearConversationBtn.addEventListener('click', () => {
    if (!currentConvo) return;
    if (currentConvo.messages && currentConvo.messages.length > 0) {
        if (confirm(`Are you sure you want to clear all messages from "${currentConvo.name || 'this conversation'}"? This cannot be undone.`)) {
            currentConvo.messages = [];
            currentConvo.tokenct = 0;
            chatLog.innerHTML = ''; // Clear the visual chat log
            promptInput.placeholder = "Ask something.. (0 tokens so far)";
            if (currentConvo.ix !== -1) { // If it's a saved conversation
                initSaveConvo(); // Re-save it (empty)
            }
            // No need to re-render list unless name changes, but saveConvo in initSaveConvo does.
        }
    } else {
        alert("Conversation is already empty.");
    }
});
// --- FEATURE: Clear Current Conversation Messages END ---

// --- Right Sidebar Tab Switching ---
const sidebarTabButtons = document.querySelectorAll('#right-sidebar-tabs .sidebar-tab-button');
const sidebarTabPanels = document.querySelectorAll('#right-sidebar-content .sidebar-panel');

sidebarTabButtons.forEach(button => {
  button.addEventListener('click', () => {
    const targetPanelId = button.dataset.tabTarget;
    const targetPanel = document.querySelector(targetPanelId);

    // Remove active class from all buttons and panels
    sidebarTabButtons.forEach(btn => btn.classList.remove('active'));
    sidebarTabPanels.forEach(panel => panel.classList.remove('active'));

    // Add active class to the clicked button and its target panel
    button.classList.add('active');
    if (targetPanel) {
      targetPanel.classList.add('active');
    }
  });
});
// Ensure the default active tab's content is shown
const initiallyActiveButton = document.querySelector('#right-sidebar-tabs .sidebar-tab-button.active');
if (initiallyActiveButton) {
    const initialTargetPanelId = initiallyActiveButton.dataset.tabTarget;
    if (initialTargetPanelId) { // Check if data-tab-target exists
        const initialActivePanel = document.querySelector(initialTargetPanelId);
        if (initialActivePanel && !initialActivePanel.classList.contains('active')) {
            sidebarTabPanels.forEach(panel => panel.classList.remove('active'));
            initialActivePanel.classList.add('active');
        }
    }
}

// --- Right Sidebar Collapse Toggle ---
const toggleRightSidebarBtn = document.getElementById('toggle-right-sidebar-btn');
const rightSidebar = document.getElementById('right-sidebar');

if (toggleRightSidebarBtn && rightSidebar) {
  toggleRightSidebarBtn.addEventListener('click', () => {
    rightSidebar.classList.toggle('right-sidebar-collapsed');
    // Optionally change button text/icon
    if (rightSidebar.classList.contains('right-sidebar-collapsed')) {
      toggleRightSidebarBtn.innerHTML = '&lsaquo;'; // ‹
      toggleRightSidebarBtn.title = "Show Settings";
    } else {
      toggleRightSidebarBtn.innerHTML = '&rsaquo;'; // ›
      toggleRightSidebarBtn.title = "Hide Settings";
    }
  });
}
</script>
</body>
</html>
